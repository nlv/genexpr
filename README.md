# Генерация арифметических выражений

## Параметры

Параметры должны быть указаны в файле `genexp.conf`:

* min - минимальное значение чисел в выражении и минимальное значение самого выражения;

* max - максимальное значение чисел в выражении и максимальное значение самого выражения;

* cnt - максимальное количество чисел в выражении;

Пример конфигурационного файла:

```haskell
min = -100
max = 100
cnt = 5
```

## Критические замечания к алгоритму

1. Для бинарных операций делаются ограничения, чтобы значения левого  и правого выражения попадали в указанный диапазон.
   Хотя, в общем случае это может быть не так.
 
   Например, сейчас  при генерировании выражения `e1 / e2`, значение выражений `e1` и `e2` автоматом попадают в указанный промежуток: 
   от -100 до 100: `(60 / (-3))`
   Хотя по заданию допустимо такое выражение: `(100 * 2) / 10` (значение левого выражения равно 200).
 
1. Для генерирования согласованных левой и правой частей бинарных выражений используется перебор случайных пар, 
   которые удовлетворяют критериям корректности для бинарных операций (` ``suchThat`` validate2`).
   Но, я думаю, этот момент абсолютно не критичен. Перебор происходит только двух пар чисел. 
   Если бы генерировались случайно какие-нибудь куски выражений и они проверялись на корректность, то это было бы критично.
 
   Если же не хотим и пары чисел перебирать, то тут надо сложнее логику делать. Например, для деления генерируем левую часть из числового промежутка,
   а правую часть только из чисел - делителей левой части (ну и ограничения на диапазоны чисел).

## Критические замечания к реализации

1. Абсолютно не существенное. Не передавать nm nx n параметрами, а задействовать Reader монаду.
   (пока делал, лишь бы заработало)
 
1. Не красиво задано соответствие между Expr, числовым кодом операций и соотв. функций haskell.
   Например, `Mul <-> 1 <-> (\*)`. В результате - потенциальные "дыры".    (пока делал, лишь бы заработало)

1. Повторяющиеся куски, например, в функции ss2'. Чтобы избавиться от них, видимо надо задействовать классы. 
   Надо различать бинарные и унарные операции.

1. Может было бы проще, если бы построение дерева сразу учитывало бы приоритет операций.

1. Возможно минимизация скобок была бы проще, если бы сначала переводили сгенерированное выражение в обратную польскую запись.
   А потом обратную польскую запись уже переводили в обычное выражение с минимальными скобками.


